> Color = 16#F09A29.
15768105
> Pixel1 = <<Color>>.                          
<<")">>
> Pixel2 = <<Color:16>>.
<<154,41>>
> Pixel3 = <<Color:24>>.
<<240,154,41>>

1）在定义Pixel1时，我们没有给bit串指定长度，所以，它默认是一个byte，而0x29恰好是字符“)”；

2）在定义Pixel2时，我们指定bit串的长度是16，我们看到他把后面16位转换为bit串，即我们看到的两个8bit长数字；

3）在定义Pixel3时，我们指定bit串的长度是24，然后我们就得到了完整的bit串-3个8bit长的bit串。

1> Pixels = <<213,45,132,4,76,32,76,0,0,234,32,15>>.
<<213,45,132,4,76,32,76,0,0,234,32,15>>
2> <<Pix1,Pix2,Pix3,Pix4>> = Pixels.
** exception error: no match of right hand side value <<213,45,132,4,76,32,76,0,0,234,32,15>>
3> <<Pix1:24,Pix2:24,Pix3:24,Pix4:24>> = Pixels.
<<213,45,132,4,76,32,76,0,0,234,32,15>>
4> <<Pix1:24>>.
<<213,45,132>>

另外，如果我们只取第一个8位，是没必要去拆开整个bit串的，Erlang给我们准备了一个语法糖：

> <<R:8,Rest/binary>> = Pixels.
<<213,45,132,4,76,32,76,0,0,234,32,15>>
> R.
213

> <<8:8/unit:2>> == <<8:16>>.
true
> <<123456:16/unit:2>>.
<<0,1,226,64>>
> <<123456:32>>.
<<0,1,226,64>>
> <<123456:24>>.
<<1,226,64>> %% (1*256*256)65536 + (226*256)57856 + 64

1> <<Y:4/unit:8>> = <<72,0,0,0>>.
<<72,0,0,0>>
2> Y.
1207959552 %% 256*256*256*72

3> <<X:4/little-unit:8>> = <<72,0,0,0>>.
<<72,0,0,0>>
4> X.
72

5> <<X:4/little-unit:8>> = <<72,2,0,0>>.
<<72,2,0,0>>
6> X. %% (256*2)512+72
584
10> 