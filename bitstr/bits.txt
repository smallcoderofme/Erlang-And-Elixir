> Color = 16#F09A29.
15768105
> Pixel1 = <<Color>>.                          
<<")">>
> Pixel2 = <<Color:16>>.
<<154,41>>
> Pixel3 = <<Color:24>>.
<<240,154,41>>

1）在定义Pixel1时，我们没有给bit串指定长度，所以，它默认是一个byte，而0x29恰好是字符“)”；

2）在定义Pixel2时，我们指定bit串的长度是16，我们看到他把后面16位转换为bit串，即我们看到的两个8bit长数字；

3）在定义Pixel3时，我们指定bit串的长度是24，然后我们就得到了完整的bit串-3个8bit长的bit串。

1> Pixels = <<213,45,132,4,76,32,76,0,0,234,32,15>>.
<<213,45,132,4,76,32,76,0,0,234,32,15>>
2> <<Pix1,Pix2,Pix3,Pix4>> = Pixels.
** exception error: no match of right hand side value <<213,45,132,4,76,32,76,0,0,234,32,15>>
3> <<Pix1:24,Pix2:24,Pix3:24,Pix4:24>> = Pixels.
<<213,45,132,4,76,32,76,0,0,234,32,15>>
4> <<Pix1:24>>.
<<213,45,132>>

另外，如果我们只取第一个8位，是没必要去拆开整个bit串的，Erlang给我们准备了一个语法糖：

> <<R:8,Rest/binary>> = Pixels.
<<213,45,132,4,76,32,76,0,0,234,32,15>>
> R.
213

> <<8:8/unit:2>> == <<8:16>>.
true
> <<123456:16/unit:2>>.
<<0,1,226,64>>
> <<123456:32>>.
<<0,1,226,64>>
> <<123456:24>>.
<<1,226,64>> %% (1*256*256)65536 + (226*256)57856 + 64

1> <<Y:4/unit:8>> = <<72,0,0,0>>.
<<72,0,0,0>>
2> Y.
1207959552 %% 256*256*256*72

3> <<X:4/little-unit:8>> = <<72,0,0,0>>.
<<72,0,0,0>>
4> X.
72

5> <<X:4/little-unit:8>> = <<72,2,0,0>>.
<<72,2,0,0>>
6> X. %% (256*2)512+72
584

binary comprehension是和Lists comprehension一样的存在。只不过，我们在描述元素属于某个bit串时，使用的符号由"<-"变成了“<=”；描述的目标是一个bit串时，我们要把最外面的“[ ]”，同样换成"<<>>"。具体可以看下面两个例子：

> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
> RGB = [ {R,G,B}||<<R:8,G:8,B:8>> <= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
这样，我们轻松的把Pixels数据转化为RGB tuple的lists。注意“<<R:8,G:8,B:8>> <= Pixels”一句，8-8-8只有24个bit，而Pixels有12 X 8个bit，所以，这里处理的时候，是按描述循环取了四次。

另一个例子恰恰相反：

> << <<R:8,G:8,B:8>> || {R,G,B} <- RGB >>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
 ps：我们要注意generator返回的bit串是什么类型，忽略的话可能会出错。比如在下面例子中：

> << <<Bin>> || Bin <- [<<3,7,5,4,7>>]>>.
** exception error: bad argument
> << <<Bin/binary>> || Bin <- [<<3,7,5,4,7>>]>>.
<<3,7,5,4,7>>